<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloomberg Source Extractor (Advanced)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; color: #333; }
        h1 { font-size: 1.2rem; color: #555; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-family: monospace; font-size: 12px; margin-bottom: 10px; box-sizing: border-box; }
        button { background-color: #000; color: #fff; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem; width: 100%; }
        button:hover { background-color: #333; }
        #output { margin-top: 30px; background: #fff; padding: 40px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); white-space: pre-wrap; font-family: Georgia, 'Times New Roman', Times, serif; font-size: 1.1rem; line-height: 1.6; display: none; }
        .error { color: red; font-weight: bold; margin-top: 10px; font-family: monospace; text-transform: uppercase; }
        .success { color: green; font-weight: bold; margin-top: 10px; font-family: monospace; }
    </style>
</head>
<body>

    <h1>Bloomberg Source Extractor (Advanced)</h1>
    <textarea id="sourceInput" placeholder="Paste all content in 'view-source:' here..."></textarea>
    <button onclick="processHTML()">Extract Article</button>
    <div id="status" class="error"></div>
    <div id="output"></div>

    <script>
        function processHTML() {
            const html = document.getElementById('sourceInput').value;
            const statusDiv = document.getElementById('status');
            const outputDiv = document.getElementById('output');
            
            statusDiv.innerText = "";
            outputDiv.style.display = 'none';
            outputDiv.innerText = "";

            if (!html) {
                statusDiv.innerText = "PLEASE PASTE SOURCE CODE FIRST.";
                return;
            }

            try {
                const text = extractBloomberg(html);
                outputDiv.innerText = text;
                outputDiv.style.display = 'block';
            } catch (e) {
                statusDiv.innerText = "EXTRACTION FAILED: " + e.message;
            }
        }

        function extractBloomberg(htmlSource) {
            let jsonStr = "";
            
            // 1. Locate the Next.js data script
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlSource, "text/html");
            const script = doc.getElementById("__NEXT_DATA__");

            if (script) {
                jsonStr = script.innerHTML;
            } else {
                throw new Error("CANNOT FIND '__NEXT_DATA__' SCRIPT. SOURCE CODE MAY BE INCOMPLETE OR FROM AN UNSUPPORTED PAGE.");
            }

            // 2. Parse JSON
            let data;
            try {
                data = JSON.parse(jsonStr);
            } catch (e) {
                throw new Error("JSON PARSING FAILED.");
            }

            // 3. Navigate the JSON structure
            const story = data?.props?.pageProps?.story;
            
            if (!story) {
                throw new Error("CANNOT FIND STORY DATA IN JSON.");
            }

            let output = [];

            // --- Header Info ---
            output.push("Bloomberg");
            output.push("");
            output.push(story.headline || "");
            
            // Summary / Dek (Strip HTML tags)
            if (story.summary && typeof story.summary === 'string') {
                 output.push(cleanText(story.summary));
            } else if (story.summaryHtml) {
                 output.push(cleanText(story.summaryHtml.replace(/<[^>]*>?/gm, '')));
            }
            output.push("");

            // Authors
            if (story.authors && Array.isArray(story.authors)) {
                const authors = story.authors.map(a => a.name).join(", ");
                output.push("By " + authors);
            } else if (story.byline) {
                output.push("By " + story.byline);
            }

            // Date
            if (story.publishedAt) {
                output.push(formatDate(story.publishedAt));
            }
            output.push("");
            output.push("------------------------------------------------");
            output.push("");

            // --- Body Content (Recursively parse text nodes) ---
            const bodyContent = story.body?.content || [];

            bodyContent.forEach(block => {
                const type = block.type;
                
                // Paragraphs: Use recursive parser to catch links, bold, italics within
                if (type === "paragraph") {
                    const text = parseRichText(block.content);
                    if (text.trim()) {
                        output.push(text);
                        output.push("");
                    }
                } 
                // Headings
                else if (type === "heading") {
                    const text = parseRichText(block.content);
                    if (text.trim()) {
                        output.push("");
                        output.push(text.toUpperCase());
                        output.push("");
                    }
                }
                // Images
                else if (type === "media" && block.subType === "photo") {
                    // Try multiple locations for caption
                    const caption = block.photo?.caption || 
                                    block.data?.photo?.caption || 
                                    block.data?.caption || 
                                    "";
                    if (caption) {
                        output.push(`[Image Caption: ${cleanText(caption)}]`);
                        output.push("");
                    }
                }
                // Lists (Bullet points)
                else if (type === "list") {
                    const items = block.content || [];
                    items.forEach(li => {
                         // ListItemBlock also has 'content' array
                         const liText = parseRichText(li.content);
                         if(liText) output.push("• " + liText);
                    });
                    output.push("");
                }
            });

            // Footer / URL
            output.push("");
            output.push("Original URL: " + (story.url || ""));

            return output.join("\n");
        }

        // --- Helper: Recursively extract text from complex content arrays ---
        // This fixes the issue where links (type: 'link') were being skipped.
        function parseRichText(contentArray) {
            if (!contentArray || !Array.isArray(contentArray)) return "";
            
            return contentArray.map(item => {
                // Case 1: Simple text node
                if (item.type === "text") {
                    return item.value || "";
                }
                // Case 2: Link node (contains nested 'content')
                // Case 3: Emphasis/Strong node (contains nested 'content')
                else if (item.content && Array.isArray(item.content)) {
                    return parseRichText(item.content);
                }
                return "";
            }).join("");
        }

        // --- Helper: Clean HTML entities like &nbsp; ---
        function cleanText(str) {
            if (!str) return "";
            return str
                .replace(/&nbsp;/g, ' ')
                .replace(/&#x27;/g, "'")
                .replace(/&amp;/g, "&")
                .replace(/&#x2019;/g, "’")
                .replace(/&#x201C;/g, "“")
                .replace(/&#x201D;/g, "”");
        }

        function formatDate(isoString) {
            try {
                const date = new Date(isoString);
                return date.toLocaleString('en-US', { 
                    year: 'numeric', month: 'long', day: 'numeric', 
                    hour: '2-digit', minute: '2-digit', timeZoneName: 'short' 
                });
            } catch (e) {
                return isoString;
            }
        }
    </script>
</body>
</html>
